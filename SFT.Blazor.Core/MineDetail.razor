@using SFT.Blazor.Core.Dialogs
@using SFT.Core.Commands
@using SFT.Core.Queries
@inject IFactoryTrackerCommands Commands
@inject IFactoryTrackerQueries Queries
@inject IDialogService DialogService
@inject ISnackbar Snackbar

@if (Mine is not null)
{
    var free = Mine.OutputPerMinute - UsedPerMinute;
    var pctUsed = Mine.OutputPerMinute > 0 ? Math.Min(1.0, (double)UsedPerMinute / (double)Mine.OutputPerMinute) : 0.0;
    var capacityColor = GetCapacityColor(pctUsed);
    var progressColor = GetProgressColor(pctUsed);

    <MudText Typo="Typo.h5" Class="mb-1">@Mine.Name</MudText>
    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-3">
        Raw resource: @(Mine.Resource?.Name ?? "?") &mdash; @Mine.OutputPerMinute.ToString("0.##")/min extraction rate
    </MudText>

    <!-- Capacity summary -->
    <MudPaper Elevation="1" Class="pa-3 mb-4" Style="@($"border-left: 4px solid {capacityColor};")">
        <div class="d-flex justify-space-between align-center mb-2">
            <MudText Typo="Typo.subtitle2">Capacity Usage</MudText>
            <MudText Typo="Typo.body2" Style="@($"color:{capacityColor}; font-weight:600;")">
                @UsedPerMinute.ToString("0.##") / @Mine.OutputPerMinute.ToString("0.##") /min used
            </MudText>
        </div>
        <MudProgressLinear Value="@(pctUsed * 100)" Color="@progressColor" Rounded="true" Size="Size.Medium" />
        <MudText Typo="Typo.caption" Class="mt-1">
            <span style="color:@capacityColor; font-weight:600;">@free.ToString("0.##") /min</span> free to use
        </MudText>
    </MudPaper>

    <!-- Mining Stations -->
    <div class="d-flex align-center mb-2 mt-4">
        <MudText Typo="Typo.h6" Class="flex-grow-1">Mining Stations</MudText>
        <MudButton StartIcon="@Icons.Material.Filled.Add" Size="Size.Small" Variant="Variant.Outlined" OnClick="OpenAddStationDialog" data-test-id="add-mining-station-btn">Add Station</MudButton>
    </div>
    @if (!Mine.MiningStations.Any())
    {
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">No mining stations configured.</MudText>
    }
    else
    {
        var totalStations = Mine.MiningStations.Sum(s => s.Quantity);
        <MudTable Items="Mine.MiningStations.OrderBy(s => s.OverclockLevel)" Dense="true" Hover="true" Class="mb-4">
            <HeaderContent>
                <MudTh>Overclock</MudTh>
                <MudTh>Output Multiplier</MudTh>
                <MudTh>Quantity</MudTh>
                <MudTh></MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd>@GetOverclockLabel(context.OverclockLevel)</MudTd>
                <MudTd>@GetOverclockMultiplier(context.OverclockLevel)</MudTd>
                <MudTd>@context.Quantity</MudTd>
                <MudTd>
                    <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" aria-label="Edit station" OnClick="() => OpenEditStationDialog(context)" />
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Color="Color.Error" aria-label="Delete station" OnClick="() => DeleteStation(context)" />
                </MudTd>
            </RowTemplate>
            <FooterContent>
                <MudTd colspan="4">
                    <MudText Typo="Typo.caption">Total stations: @totalStations</MudText>
                </MudTd>
            </FooterContent>
        </MudTable>
    }

    <!-- Outputs -->
    <div class="d-flex align-center mb-2 mt-4">
        <MudText Typo="Typo.h6" Class="flex-grow-1">Outputs</MudText>
        <MudButton StartIcon="@Icons.Material.Filled.Add" Size="Size.Small" Variant="Variant.Outlined" OnClick="OpenAddOutputDialog" data-test-id="add-mine-output-btn">Add Output</MudButton>
    </div>
    @if (!Mine.Outputs.Any())
    {
        <MudText Typo="Typo.body2" Color="Color.Secondary">No outputs configured. Add an output to specify what this mine delivers.</MudText>
    }
    else
    {
        <MudTable Items="Mine.Outputs.OrderBy(o => o.Resource?.Name)" Dense="true" Hover="true">
            <HeaderContent>
                <MudTh>Resource</MudTh>
                <MudTh>Total / min</MudTh>
                <MudTh>Used / min</MudTh>
                <MudTh>Free / min</MudTh>
                <MudTh>Ore consumed / min</MudTh>
                <MudTh></MudTh>
            </HeaderContent>
            <RowTemplate>
                @{
                    var outUsed = GetMineOutputUsed(context.ResourceId);
                    var outFree = context.AmountPerMinute - outUsed;
                    var outPct = context.AmountPerMinute > 0 ? Math.Min(1.0, (double)outUsed / (double)context.AmountPerMinute) : 0.0;
                    var capacityColor = GetCapacityColor(outPct);
                }
                <MudTd>@context.Resource?.Name</MudTd>
                <MudTd>@context.AmountPerMinute.ToString("0.##")</MudTd>
                <MudTd>@outUsed.ToString("0.##")</MudTd>
                <MudTd>
                    <span style="color:@capacityColor; font-weight:600;">@outFree.ToString("0.##")</span>
                    <MudProgressLinear Value="@(outPct * 100)" Color="@GetProgressColor(outPct)" Rounded="true" Size="Size.Small" Class="mt-1" Style="max-width:80px;" />
                </MudTd>
                <MudTd>@context.InputAmountPerMinute.ToString("0.##")</MudTd>
                <MudTd>
                    <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" aria-label="Edit output" OnClick="() => OpenEditOutputDialog(context)" />
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Color="Color.Error" aria-label="Delete output" OnClick="() => DeleteOutput(context)" />
                </MudTd>
            </RowTemplate>
        </MudTable>
    }
}

@code {
    [Parameter] public Mine? Mine { get; set; }
    [Parameter] public decimal UsedPerMinute { get; set; }
    [Parameter] public IReadOnlyList<FactoryLevel> AllLevels { get; set; } = [];
    [Parameter] public EventCallback OnChanged { get; set; }

    private IReadOnlyList<Resource> _producibleResources = [];

    private decimal GetMineOutputUsed(int resourceId) =>
        Mine is null ? 0m :
        AllLevels
            .SelectMany(l => l.Inputs)
            .Where(i => i.SourceMineId == Mine.Id && i.ResourceId == resourceId)
            .Sum(i => i.AmountPerMinute);

    private static string GetOverclockLabel(int level) => level switch
    {
        0 => "No Overclock",
        1 => "+1 Overclock",
        2 => "+2 Overclocks",
        3 => "+3 Overclocks",
        _ => $"+{level} Overclocks"
    };

    private static string GetOverclockMultiplier(int level) => level switch
    {
        0 => "100%",
        1 => "150%",
        2 => "200%",
        3 => "300%",
        _ => "?"
    };

    private async Task OpenAddStationDialog()
    {
        var parameters = new DialogParameters<MiningStationDialog>
        {
            { x => x.MineId, Mine!.Id }
        };
        var dialog = await DialogService.ShowAsync<MiningStationDialog>("Add Mining Station", parameters);
        var result = await dialog.Result;
        if (!result!.Canceled && result.Data is MiningStation station)
        {
            if (Mine!.MiningStations.Any(s => s.OverclockLevel == station.OverclockLevel))
            {
                Snackbar.Add("A mining station with this overclock level already exists for this mine.", Severity.Warning);
                return;
            }
            try
            {
                await Commands.AddMiningStationAsync(station);
                await OnChanged.InvokeAsync();
                Snackbar.Add("Mining station added.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error adding mining station: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task OpenEditStationDialog(MiningStation station)
    {
        var parameters = new DialogParameters<MiningStationDialog>
        {
            { x => x.Station, station },
            { x => x.MineId, Mine!.Id }
        };
        var dialog = await DialogService.ShowAsync<MiningStationDialog>("Edit Mining Station", parameters);
        var result = await dialog.Result;
        if (!result!.Canceled && result.Data is MiningStation updated)
        {
            if (Mine!.MiningStations.Any(s => s.OverclockLevel == updated.OverclockLevel && s.Id != updated.Id))
            {
                Snackbar.Add("A mining station with this overclock level already exists for this mine.", Severity.Warning);
                return;
            }
            try
            {
                await Commands.UpdateMiningStationAsync(updated);
                await OnChanged.InvokeAsync();
                Snackbar.Add("Mining station updated.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error updating mining station: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task DeleteStation(MiningStation station)
    {
        var parameters = new DialogParameters<ConfirmDialog>
        {
            { x => x.Message, $"Are you sure you want to delete the {GetOverclockLabel(station.OverclockLevel)} station (x{station.Quantity})?" }
        };
        var dialog = await DialogService.ShowAsync<ConfirmDialog>("Delete Mining Station", parameters);
        var result = await dialog.Result;
        if (!result!.Canceled)
        {
            try
            {
                await Commands.DeleteMiningStationAsync(station.Id);
                await OnChanged.InvokeAsync();
                Snackbar.Add("Mining station deleted.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error deleting mining station: {ex.Message}", Severity.Error);
            }
        }
    }

    private static string GetCapacityColor(double pct) => pct switch
    {
        >= 1.0 => "var(--mud-palette-error)",
        >= 0.75 => "var(--mud-palette-warning)",
        _ => "var(--mud-palette-success)"
    };

    private static Color GetProgressColor(double pct) => pct switch
    {
        >= 1.0 => Color.Error,
        >= 0.75 => Color.Warning,
        _ => Color.Success
    };

    protected override async Task OnParametersSetAsync()
    {
        if (Mine is not null)
            _producibleResources = await Queries.GetResourcesProducibleFromAsync(Mine.ResourceId);
    }

    private IReadOnlyList<Resource> GetAvailableResources(int? excludeOutputId = null)
    {
        var usedResourceIds = Mine!.Outputs
            .Where(o => excludeOutputId == null || o.Id != excludeOutputId)
            .Select(o => o.ResourceId)
            .ToHashSet();
        return _producibleResources.Where(r => !usedResourceIds.Contains(r.Id)).ToList();
    }

    private async Task OpenAddOutputDialog()
    {
        var parameters = new DialogParameters<MineOutputDialog>
        {
            { x => x.MineId, Mine!.Id },
            { x => x.MineResourceId, Mine!.ResourceId },
            { x => x.Resources, GetAvailableResources() }
        };
        var dialog = await DialogService.ShowAsync<MineOutputDialog>("Add Output", parameters);
        var result = await dialog.Result;
        if (!result!.Canceled && result.Data is MineOutput output)
        {
            if (Mine!.Outputs.Any(o => o.ResourceId == output.ResourceId))
            {
                Snackbar.Add("This resource is already added as an output for this mine.", Severity.Warning);
                return;
            }
            try
            {
                await Commands.AddMineOutputAsync(output);
                await OnChanged.InvokeAsync();
                Snackbar.Add("Output added.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error adding output: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task OpenEditOutputDialog(MineOutput output)
    {
        var parameters = new DialogParameters<MineOutputDialog>
        {
            { x => x.Output, output },
            { x => x.MineResourceId, Mine!.ResourceId },
            { x => x.Resources, GetAvailableResources(output.Id) }
        };
        var dialog = await DialogService.ShowAsync<MineOutputDialog>("Edit Output", parameters);
        var result = await dialog.Result;
        if (!result!.Canceled && result.Data is MineOutput updated)
        {
            if (Mine!.Outputs.Any(o => o.ResourceId == updated.ResourceId && o.Id != updated.Id))
            {
                Snackbar.Add("This resource is already added as an output for this mine.", Severity.Warning);
                return;
            }
            try
            {
                await Commands.UpdateMineOutputAsync(updated);
                await OnChanged.InvokeAsync();
                Snackbar.Add("Output updated.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error updating output: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task DeleteOutput(MineOutput output)
    {
        var parameters = new DialogParameters<ConfirmDialog>
        {
            { x => x.Message, $"Are you sure you want to delete the output \"{output.Resource?.Name}\"?" }
        };
        var dialog = await DialogService.ShowAsync<ConfirmDialog>("Delete Output", parameters);
        var result = await dialog.Result;
        if (!result!.Canceled)
        {
            try
            {
                await Commands.DeleteMineOutputAsync(output.Id);
                await OnChanged.InvokeAsync();
                Snackbar.Add("Output deleted.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error deleting output: {ex.Message}", Severity.Error);
            }
        }
    }
}
